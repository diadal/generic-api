{"name":"Generic API","tagline":"API Abstraction layer with mocks.Connect to external API easy and follow some simple guidelines.","body":"# Generic API\r\n\r\n[![Build Status](https://travis-ci.org/toplib/generic-api.svg?branch=master)](https://travis-ci.org/toplib/generic-api)\r\n[![Coverage Status](https://coveralls.io/repos/toplib/generic-api/badge.svg?branch=master&service=github)](https://coveralls.io/github/toplib/generic-api?branch=master)\r\n[![Latest Stable Version](https://poser.pugx.org/toplib/generic-api/version)](https://packagist.org/packages/toplib/generic-api)\r\n[![Latest Unstable Version](https://poser.pugx.org/toplib/generic-api/v/unstable)](//packagist.org/packages/toplib/generic-api)\r\n[![Total Downloads](https://poser.pugx.org/toplib/generic-api/downloads)](https://packagist.org/packages/toplib/generic-api)\r\n[![License](https://poser.pugx.org/toplib/generic-api/license)](https://packagist.org/packages/toplib/generic-api)\r\n\r\nAPI Abstraction layer with mocks.Connect to external API easy and follow some simple guidelines.\r\n\r\n\r\nMost APIs provide a SDK or API implementation library in parallel.\r\nBut this not always true, or simply not made in our required language (php).\r\nFor this cases is necessary implements the API from scratch.\r\nGenericApi is solution to keep things organized and follow a similar pattern for all libraries.\r\n\r\n## Features\r\n\r\n- **Mocks:** Emulate request and response for test environments\r\n- **Validation:** Use powerful symfony validations to validate a request before send to a server\r\n- **Connection Abstraction:** Only create the request, the connection is done automatically with guzzle, no more complicated curl connections.\r\n- **Xml and Json Parser:** Can use XML and JSON parser to convert API response to objects using JMS serializer\r\n- **Scaffolding:** Test API connection and any method using generic classes\r\n\r\n## Installation\r\n\r\n1. [Install composer](https://getcomposer.org/download/)\r\n2. Execute: `composer require toplib/generic-api`\r\n\r\n## Implementing specific API\r\n\r\n### Creating the API\r\n\r\nFirstly create a empty class for your API that extends of GenericApi class. Some methods will be created later.\r\n\r\n````php\r\nuse Toplib\\GenericApi\\GenericApi;\r\nclass SampleAPI extends GenericApi\r\n{\r\n````\r\n\r\n### Creating a Service\r\n\r\nA service is the class required to do some specific action, ej. DeleteUser is the service to delete some specific user.\r\n\r\nEach service must implements ApiServiceInterface.\r\nShould return a valid `ApiRequest` in the method `getApiRequest` and should parse the response in the method `parseResponse`.\r\nThe response can vary depending of your needs.\r\n\r\n````php\r\nuse Toplib\\GenericApi\\ApiFactory;\r\nuse Toplib\\GenericApi\\ApiServiceInterface;\r\nuse Toplib\\GenericApi\\Serializer\\JsonMessageParser;\r\n\r\nclass GetPost implements ApiServiceInterface\r\n{\r\n    /**\r\n     * @Assert\\NotBlank()\r\n     */\r\n    private $postId;\r\n\r\n    /**\r\n     * GetPost constructor.\r\n     *\r\n     * @param $postId\r\n     */\r\n    public function __construct($postId)\r\n    {\r\n        $this->postId = $postId;\r\n    }\r\n\r\n    /**\r\n     * @return mixed\r\n     */\r\n    public function getPostId()\r\n    {\r\n        return $this->postId;\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public function getApiRequest(ApiInterface $api)\r\n    {\r\n       $url = sprintf('http://jsonplaceholder.typicode.com/posts/%s', $this->getPostId());\r\n\r\n       return ApiFactory::createRequest('get', $url);\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public function parseResponse(ResponseInterface $response, ApiInterface $api)\r\n    {\r\n        return new JsonMessageParser('Toplib\\\\SampleApi\\\\Model\\\\Post');\r\n    }\r\n}\r\n````\r\n\r\n> Note: No communication happen in the service, only build the request required to send to the external server.\r\n\r\nWhen create the request in the service can customize a lot of options to create advanced requests\r\n\r\n````php\r\n$request =  ApiFactory::createRequest('get', $url);\r\n\r\n$request->SSLVerification(false)\r\n        ->setJson(['post'=>['id'=>1]])\r\n        ->setAuth('username','password')\r\n        ->setAuth('username','password')\r\n        ->setCurlOption(CURLOPT_CAPATH,'/var/...')\r\n        ...\r\n\r\n``````\r\nTo view all available options see the [guzzle documentation](http://docs.guzzlephp.org/en/5.3/clients.html#request-options).\r\n\r\n### Create the public method in the API class\r\n\r\nIt's the user/developer end-point to use the api, you must create a way to call the service\r\n\r\n````php\r\n/**\r\n * Class SampleAPI\r\n */\r\nclass SampleAPI extends GenericApi\r\n{\r\n\r\n    /**\r\n     * @param $id\r\n     *\r\n     * @return Post\r\n     * @throws \\Toplib\\GenericApi\\Exception\\ApiException\r\n     */\r\n    public function getPost($id)\r\n    {\r\n        $service = new GetPost();\r\n        $service->setPostId($id);\r\n\r\n        return $this->process($service);\r\n    }\r\n}\r\n````\r\n\r\nalternatively without create the public method, the service can be used as is.\r\n\r\n````php\r\n    $api = new SampleApi();\r\n    $service = new GetPost();\r\n    $service->setPostId(1);\r\n    $response = $api->process($service);\r\n    //parse the response\r\n````\r\n\r\nBut use a public method is very easy\r\n\r\n````php\r\n    $api = new SampleApi();\r\n    $post = $api->get(1);\r\n````\r\n\r\n### Validation\r\n\r\nValidate service data before send the request to a remote server. Use Symfony validation annotations.\r\n\r\n````php\r\n    /**\r\n     * @Assert\\\\NotBlank()\r\n     */\r\n    private $postId;\r\n````\r\n\r\nValidations are triggered just before send the request to a remote server or mock.\r\n\r\n### Serialization\r\n\r\nCan use jms/serializer or any other library to send/receive data.\r\n\r\n````php\r\n   ...\r\n   $xmlBody = SerializerBuilder::create()->build()->serialize($this, 'xml');\r\n   return ApiFactory::createRequest('post', $url, $xmlBody);\r\n````\r\n\r\nIn the `parseResponse` method of the service you receive a raw response from the server\r\n````php\r\n public function parseResponse(ResponseInterface $response, ApiInterface $api)\r\n\r\n````\r\nCan manage and return the response as you need. Or can use one of the following parsers:\r\n\r\n- JsonMessageParser\r\n- XMLMessageParser\r\n\r\nThe above parsers deserialize the responses automatically.\r\n\r\n##### Example:\r\n\r\nusing `JsonMessageParser` (based on JMS\\Serializer)\r\n````php\r\nreturn JsonMessageParser('Toplib\\\\SampleApi\\\\Model\\\\Post');\r\n````\r\nor manually\r\n````php\r\n$responseJson = $response->getBody()->getContents();\r\n$postArray = json_decode($responseJson, true);\r\n$post = new Post();\r\n$post->setId($postArray['id']);\r\n$post->setUserId($postArray['userId']);\r\n$post->setTitle($postArray['title']);\r\n$post->setBody($postArray['body']);\r\n\r\nreturn $post;\r\n````\r\n\r\n### Mocking a service\r\n\r\nThe mock is a optional param when create a api request in the service and emulate the HTTP layer without needing to send requests over the internet.\r\nMocks are very useful to emulate responses for test environments, developing or refactoring the api without need of send real requests.\r\n\r\n````php\r\n/**\r\n * Class GetPostMock\r\n */\r\nclass GetPostMock implements ApiMockInterface\r\n{\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public function mock(RequestInterface $request)\r\n    {\r\n        $post = [\r\n            'userId' => 1,\r\n            'id' => 1,\r\n            'title' => 'sunt aut facere repellat provident ...',\r\n            'body' => 'quia et suscipit suscipit recusandae consequuntur expedita ...',\r\n        ];\r\n\r\n        return ApiFactory::createResponse(json_encode($post, 1));\r\n    }\r\n}\r\n\r\n````\r\n\r\nshould be settled when create the request in the service\r\n\r\n````php\r\n    return ApiFactory::createRequest('get', $url, [], [], new GetPostMock());\r\n````\r\n\r\nand change the mode of your API\r\n\r\n````php\r\n$api->setMode(ApiInterface::MODE_MOCK);\r\n````\r\n\r\n### Generic classes for Scaffolding\r\n\r\nFor rapid scaffolding, tests or small services can use generic classes as is.\r\nWithout the need of create a class for that service.\r\n\r\n````php\r\n$api = new GenericApi(ApiInterface::MODE_LIVE);\r\n\r\n$request = ApiFactory::createRequest('get', 'http://jsonplaceholder.typicode.com/posts/1');\r\n$service = new GenericApiService($request);\r\n$response = $api->process($service);\r\n````\r\n\r\nBelow the same example but mocking the response. Generic mock can be created using a callable function in this case.\r\n\r\n````php\r\n$api = new GenericApi(ApiInterface::MODE_MOCK);\r\n\r\n$request = ApiFactory::createRequest('get', 'http://jsonplaceholder.typicode.com/posts/1');\r\n\r\n$mockCallback = function (RequestInterface $request) {\r\n    $post = [\r\n        'userId' => 1,\r\n        'id' => 1,\r\n        'title' => 'sunt aut facere repellat provident occaecati excepturi optio reprehenderit',\r\n        'body' => 'quia et suscipit suscipit recusandae consequuntur expedita et cum reprehenderit molestiae ut ut quas totam nostrum rerum est autem sunt rem eveniet architecto',\r\n    ];\r\n\r\n    return ApiFactory::createResponse(json_encode($post, 1));\r\n};\r\n$request->setMock(new GenericApiMock($mockCallback));\r\n\r\n$service = new GenericApiService($request);\r\n$response = $api->process($service);\r\n````\r\n\r\n## Functional Example\r\n\r\nCan view a more complex example of functional API in the \"sample\" folder.\r\n\r\n## Copyright\r\n\r\nThis project is licensed under the [MIT license](LICENSE).","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}